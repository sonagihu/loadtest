 [기능] Code Enhancement (코드 개선)
[길이] Long (긴 요청)
[복잡도] Advanced (고급)
[설명] 분산 메시징 큐 시스템의 코드 개선

다음 분산 메시징 큐 시스템의 코드를 개선해줘:
```java
public class Message {
    private String id;
    private String content;
    private long timestamp;
    private MessageStatus status;
    private int retryCount;
    private String source;
    private Map<String, String> metadata;
    
    public Message(String id, String content, String source) {
        this.id = id;
        this.content = content;
        this.timestamp = System.currentTimeMillis();
        this.status = MessageStatus.PENDING;
        this.retryCount = 0;
        this.source = source;
        this.metadata = new HashMap<>();
    }
    
    public void setStatus(MessageStatus status) {
        this.status = status;
    }
    
    public void incrementRetryCount() {
        this.retryCount++;
    }
    
    public void addMetadata(String key, String value) {
        this.metadata.put(key, value);
    }
    
    public String getId() {
        return id;
    }
    
    public String getContent() {
        return content;
    }
    
    public long getTimestamp() {
        return timestamp;
    }
    
    public MessageStatus getStatus() {
        return status;
    }
    
    public int getRetryCount() {
        return retryCount;
    }
    
    public String getSource() {
        return source;
    }
    
    public Map<String, String> getMetadata() {
        return Collections.unmodifiableMap(metadata);
    }
}

public enum MessageStatus {
    PENDING, PROCESSING, COMPLETED, FAILED, RETRY
}

public interface MessageQueue {
    void publish(Message message) throws QueueException;
    Message consume() throws QueueException;
    void acknowledge(String messageId) throws QueueException;
    void reject(String messageId) throws QueueException;
    void retry(String messageId) throws QueueException;
    List<Message> getDeadLetterQueue() throws QueueException;
}

public class DistributedMessageQueue implements MessageQueue {
    private final Map<String, Queue<Message>> queues;
    private final Map<String, Message> processingMessages;
    private final Queue<Message> deadLetterQueue;
    private final Object lock;
    private final int maxRetries;
    private final long retryDelay;
    
    public DistributedMessageQueue(int maxRetries, long retryDelay) {
        this.queues = new ConcurrentHashMap<>();
        this.processingMessages = new ConcurrentHashMap<>();
        this.deadLetterQueue = new ConcurrentLinkedQueue<>();
        this.lock = new Object();
        this.maxRetries = maxRetries;
        this.retryDelay = retryDelay;
    }
    
    @Override
    public void publish(Message message) throws QueueException {
        synchronized (lock) {
            String queueName = getQueueName(message);
            Queue<Message> queue = queues.computeIfAbsent(queueName, k -> new ConcurrentLinkedQueue<>());
            queue.offer(message);
        }
    }
    
    @Override
    public Message consume() throws QueueException {
        synchronized (lock) {
            for (Queue<Message> queue : queues.values()) {
                Message message = queue.poll();
                if (message != null) {
                    message.setStatus(MessageStatus.PROCESSING);
                    processingMessages.put(message.getId(), message);
                    return message;
                }
            }
            return null;
        }
    }
    
    @Override
    public void acknowledge(String messageId) throws QueueException {
        synchronized (lock) {
            Message message = processingMessages.remove(messageId);
            if (message != null) {
                message.setStatus(MessageStatus.COMPLETED);
            }
        }
    }
    
    @Override
    public void reject(String messageId) throws QueueException {
        synchronized (lock) {
            Message message = processingMessages.remove(messageId);
            if (message != null) {
                if (message.getRetryCount() < maxRetries) {
                    retry(messageId);
                } else {
                    message.setStatus(MessageStatus.FAILED);
                    deadLetterQueue.offer(message);
                }
            }
        }
    }
    
    @Override
    public void retry(String messageId) throws QueueException {
        synchronized (lock) {
            Message message = processingMessages.remove(messageId);
            if (message != null) {
                message.incrementRetryCount();
                message.setStatus(MessageStatus.RETRY);
                message.addMetadata("lastRetryTime", String.valueOf(System.currentTimeMillis()));
                
                try {
                    Thread.sleep(retryDelay);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    throw new QueueException("Retry interrupted", e);
                }
                
                String queueName = getQueueName(message);
                Queue<Message> queue = queues.get(queueName);
                if (queue != null) {
                    queue.offer(message);
                }
            }
        }
    }
    
    @Override
    public List<Message> getDeadLetterQueue() throws QueueException {
        return new ArrayList<>(deadLetterQueue);
    }
    
    private String getQueueName(Message message) {
        return "queue-" + Math.abs(message.getId().hashCode() % 3);
    }
}

public class QueueException extends Exception {
    public QueueException(String message) {
        super(message);
    }
    
    public QueueException(String message, Throwable cause) {
        super(message, cause);
    }
}

public class MessageProcessor {
    private final MessageQueue queue;
    private final ExecutorService executorService;
    private final ScheduledExecutorService retryExecutor;
    private volatile boolean running;
    
    public MessageProcessor(MessageQueue queue) {
        this.queue = queue;
        this.executorService = Executors.newFixedThreadPool(3);
        this.retryExecutor = Executors.newScheduledThreadPool(1);
        this.running = true;
    }
    
    public void start() {
        for (int i = 0; i < 3; i++) {
            executorService.submit(this::processMessages);
        }
        retryExecutor.scheduleAtFixedRate(this::checkRetries, 1, 1, TimeUnit.MINUTES);
    }
    
    public void stop() {
        running = false;
        executorService.shutdown();
        retryExecutor.shutdown();
        try {
            if (!executorService.awaitTermination(60, TimeUnit.SECONDS)) {
                executorService.shutdownNow();
            }
            if (!retryExecutor.awaitTermination(60, TimeUnit.SECONDS)) {
                retryExecutor.shutdownNow();
            }
        } catch (InterruptedException e) {
            executorService.shutdownNow();
            retryExecutor.shutdownNow();
            Thread.currentThread().interrupt();
        }
    }
    
    private void processMessages() {
        while (running) {
            try {
                Message message = queue.consume();
                if (message != null) {
                    processMessage(message);
                } else {
                    Thread.sleep(100);
                }
            } catch (QueueException | InterruptedException e) {
                // 에러 처리 로직
            }
        }
    }
    
    private void processMessage(Message message) {
        try {
            // 메시지 처리 로직
            queue.acknowledge(message.getId());
        } catch (Exception e) {
            try {
                queue.reject(message.getId());
            } catch (QueueException ex) {
                // 에러 처리 로직
            }
        }
    }
    
    private void checkRetries() {
        try {
            List<Message> deadLetterQueue = queue.getDeadLetterQueue();
            for (Message message : deadLetterQueue) {
                if (message.getStatus() == MessageStatus.RETRY) {
                    queue.retry(message.getId());
                }
            }
        } catch (QueueException e) {
            // 에러 처리 로직
        }
    }
}

public class MessageConsumer {
    private final MessageQueue queue;
    private final MessageHandler handler;
    private final ExecutorService executorService;
    private volatile boolean running;
    
    public MessageConsumer(MessageQueue queue, MessageHandler handler) {
        this.queue = queue;
        this.handler = handler;
        this.executorService = Executors.newSingleThreadExecutor();
        this.running = true;
    }
    
    public void start() {
        executorService.submit(this::consumeMessages);
    }
    
    public void stop() {
        running = false;
        executorService.shutdown();
        try {
            if (!executorService.awaitTermination(60, TimeUnit.SECONDS)) {
                executorService.shutdownNow();
            }
        } catch (InterruptedException e) {
            executorService.shutdownNow();
            Thread.currentThread().interrupt();
        }
    }
    
    private void consumeMessages() {
        while (running) {
            try {
                Message message = queue.consume();
                if (message != null) {
                    handler.handleMessage(message);
                    queue.acknowledge(message.getId());
                } else {
                    Thread.sleep(100);
                }
            } catch (QueueException | InterruptedException e) {
                // 에러 처리 로직
            }
        }
    }
}

public interface MessageHandler {
    void handleMessage(Message message) throws Exception;
}
```